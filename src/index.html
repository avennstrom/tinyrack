<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preload" href="rack.wasm" as="fetch" type="application/wasm" crossorigin>
    <link rel="preload" href="font.webp" as="image" type="image/webp">
    <title>rack.fm</title>
    <style>
        body {
            padding: 0;
            margin: 0;
            background-color: #3c5377;
        }
        canvas {
            border: 0px none;
            background-color: #3c5377;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        #github {
            position: fixed;
            left: 16px;
            top: 16px;
        }
        #github img {
            width: 64px;
            height: 64px;
        }
    </style>
</head>

<body>
    <canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
    <a id="github" href="https://github.com/avennstrom/tinyrack" title="Check out the source code on GitHub!" target="_blank">
        <img src="github.svg" alt="GitHub Logo">
    </a>

    <script>
        let t0 = performance.now();
        let gl = canvas.getContext("webgl2", { antialias: true });
        let t1 = performance.now();
        console.log(`webgl2: ${t1 - t0} ms`);

        var instance = null;

        let font_texture = null;

        const image = new Image();
        image.src = "font.webp";
        image.onload = () => {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            font_texture = tex;
        }

        const vertex_buffer = gl.createBuffer();
        const vao = gl.createVertexArray();

        function compile(src, type) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
            }
            return s;
        }

        function create_program(vs_src, fs_src) {
            const program = gl.createProgram();
            gl.attachShader(program, compile(vs_src, gl.VERTEX_SHADER));
            gl.attachShader(program, compile(fs_src, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            return {
                program,
                u_view: gl.getUniformLocation(program, "uView"),
                u_projection: gl.getUniformLocation(program, "uProjection"),
            };
        }

        const programs = [
            create_program(`___COLOR_VERT___`, `___COLOR_FRAG___`),
            create_program(`___FONT_VERT___`, `___FONT_FRAG___`),
        ];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (instance) instance.exports.js_canvas_size(canvas.width, canvas.height);
        }
        window.addEventListener("resize", resize);
        resize();

        function js_set_cursor(cursor) {
            let canvas = document.getElementById('canvas');
            let style = 'pointer';
            switch (cursor) {
                case 0: style = 'default'; break;
                case 1: style = 'pointer'; break;
                case 2: style = 'crosshair'; break;
                case 3: style = 'arrow'; break;
                case 4: style = 'grab'; break;
                case 5: style = 'grabbing'; break;
                case 6: style = 'no-drop'; break;
                case 7: style = 'move'; break;
            }
            canvas.style.cursor = style;
        }

        function js_render(draw_ptr, draw_count, vertex_data_ptr, vertex_count) {
            //console.log({draw_ptr, draw_count, vertex_data_ptr, vertex_count});
            const vertex_stride = 16;
            const vertex_data = new Uint8Array(instance.exports.memory.buffer, vertex_data_ptr, vertex_count * vertex_stride);

            gl.bindVertexArray(vao);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertex_data, gl.STREAM_DRAW);

            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, vertex_stride, 0);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, true, vertex_stride, 8);
            gl.enableVertexAttribArray(2);
            gl.vertexAttribIPointer(2, 1, gl.UNSIGNED_INT, vertex_stride, 12);

            gl.activeTexture(gl.TEXTURE0);
            if (font_texture !== undefined) {
                gl.bindTexture(gl.TEXTURE_2D, font_texture);
            }

            const W = canvas.width;
            const H = canvas.height;
            const proj = new Float32Array([
                2 / W, 0, 0, 0,
                0, -2 / H, 0, 0,
                0, 0, -1, 0,
                -1, 1, 0, 1
            ]);

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(60 / 255, 83 / 255, 119 / 255, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            const dv = new DataView(instance.exports.memory.buffer);

            let current_program = -1;

            for (let i = 0; i < draw_count; ++i) {
                const draw_base_ptr = draw_ptr + i * (64 + 16);
                const view = new Float32Array(instance.exports.memory.buffer, draw_base_ptr, 16);
                const program_index = dv.getInt32(draw_base_ptr + 64, true);
                const topology = dv.getInt32(draw_base_ptr + 64 + 4, true);
                const vertex_offset = dv.getUint32(draw_base_ptr + 64 + 8, true);
                const vertex_count = dv.getUint32(draw_base_ptr + 64 + 12, true);
                //console.log({ program_index, topology, vertex_offset, vertex_count });

                const program = programs[program_index];

                if (current_program != program_index) {
                    current_program = program_index;
                    gl.useProgram(program.program);
                    gl.uniformMatrix4fv(program.u_projection, false, proj);

                    if (program_index === 1) {
                        const u_font = gl.getUniformLocation(program.program, "uFont");
                        gl.uniform1i(u_font, 0);
                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    }
                    else {
                        gl.disable(gl.BLEND);
                    }
                }

                gl.uniformMatrix4fv(program.u_view, true, view);

                gl.drawArrays(topology, vertex_offset, vertex_count);
            }
        }

        const imports = {
            env: {
                js_now: () => performance.now(),
                js_render,
                js_set_cursor,
                console_log: (ptr) => {
                    const mem = new Uint8Array(instance.exports.memory.buffer);
                    let s = "";
                    for (let i = ptr; mem[i] !== 0; i++) {
                        s += String.fromCharCode(mem[i]);
                    }
                    console.log(s);
                },
            }
        };

        (async () => {
            const wasm = await WebAssembly.instantiateStreaming(fetch('rack.wasm'), imports);
            instance = wasm.instance;
            instance.exports._start();
            instance.exports.js_canvas_size(canvas.width, canvas.height);

            window.addEventListener('mousedown', (ev) => {
                instance.exports.js_mousedown(ev.button);
                if (audioCtx) audioCtx.resume();
            });
            window.addEventListener('mouseup', (ev) => {
                instance.exports.js_mouseup(ev.button);
            });
            window.addEventListener('mousemove', (ev) => {
                instance.exports.js_mousemove(ev.clientX, ev.clientY);
            });
            window.addEventListener('keydown', (ev) => {
                if (ev.key === "Tab") ev.preventDefault();
                instance.exports.js_keydown(ev.keyCode);
            });
            window.addEventListener('keyup', (ev) => {
                instance.exports.js_keyup(ev.keyCode);
            });
            window.addEventListener('wheel', (ev) => {
                //console.log('wheel: ' + ev.deltaY);
                instance.exports.js_mousewheel(ev.deltaX, ev.deltaY);
            });

            function frame() {
                instance.exports.tr_frame_update_draw();
                window.requestAnimationFrame(frame);
            }

            window.requestAnimationFrame(frame);

            const audio_blocksize = 128;
            const audio_bufcount = 8; // how many 128-sample blocks to buffer

            const audioCtx = new AudioContext({ sampleRate: 48000 });
            await audioCtx.audioWorklet.addModule(URL.createObjectURL(new Blob([`___AUDIO_PROCESSOR___`], {type: "application/javascript"})));
            const node = new AudioWorkletNode(audioCtx, "rack", {
                processorOptions: {
                    sab: new SharedArrayBuffer(4 * audio_blocksize * audio_bufcount),
                    count: audio_bufcount,
                },
            });
            node.connect(audioCtx.destination);

            const pcm_ptr = instance.exports.pcm_alloc();
            const pcm = new Float32Array(instance.exports.memory.buffer, pcm_ptr, audio_blocksize);

            node.port.onmessage = (event) => {
                const pcm_buf = event.data;
                instance.exports.tr_audio_callback(pcm_ptr, audio_blocksize);
                pcm_buf.set(pcm);
            };

            audioCtx.resume();
        })();
    </script>
</body>

</html>